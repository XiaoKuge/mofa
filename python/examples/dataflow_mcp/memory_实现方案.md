LangGraph 的 **Memory** 系统采用了灵活的多层次存储架构，包含两种不同类型的内存：**短期内存** 和 **长期内存**，分别使用不同的存储方案和技术。这些内存类型帮助系统管理对话中的上下文和跨会话的知识。

### **Memory 系统概述**

LangGraph 的内存系统根据召回范围分为两类：

* **短期内存（Thread-scoped）**：用于追踪当前会话的对话历史，维护线程范围内的会话状态。
* **长期内存**：用于存储跨会话的用户特定数据或应用级数据，并在不同的对话线程间共享。

### **短期内存存储**

1. **存储机制**：

   * 短期内存作为 **线程状态的一部分**，并通过 **线程范围内的检查点（checkpoints）** 持久化。可以存储对话历史、上传的文件、检索的信息以及生成的工件。

2. **存储的内容**：

   * 对话历史（人类与 AI 之间的消息）
   * 会话特定的状态数据（如任务进度）
   * 上传的文件和文档
   * 检索的信息和生成的工件

3. **存储技术**：

   * **内存存储（In-Memory Storage）**
   * **PostgreSQL**
   * **MongoDB**
   * **Redis**

### **长期内存存储**

1. **存储机制**：

   * 长期内存将信息存储在自定义的“命名空间”中，并使用支持在任何线程中随时召回数据的存储。数据以 **JSON 文档** 的形式存储，每个内存条目都可以通过命名空间（类似文件夹）和独特的键（类似文件名）进行组织。

2. **记忆类型和内容**：
   长期内存支持三种基于人类记忆研究的内存类型：

   * **语义记忆（Semantic Memory）**：存储事实、概念，如用户偏好、档案或从交互中学习到的事实信息。
   * **情景记忆（Episodic Memory）**：存储过去的经验和行动，通常通过少量样本提示（few-shot prompting）帮助代理基于过去的序列正确执行任务。
   * **程序性记忆（Procedural Memory）**：存储执行任务的规则和指令，通常包括代理的提示和系统指令，可以根据反馈进行修改。

3. **存储技术和方案**：

   * 所有长期内存存储都继承自 **BaseStore**，提供一个统一的接口，用于持久化的键值存储，并支持分层的命名空间和可选的向量搜索能力。
   * 可选存储后端：

     * **内存存储（In-Memory Store）**：基于字典的存储，适用于开发，但进程退出后数据丢失。
     * **PostgreSQL 存储**：支持完整 SQL 功能的持久化存储，并通过 **pgvector** 扩展支持向量搜索。

4. **数据组织**：

   * 每个条目都存储有综合的元数据，包括命名空间（层次路径）、键（唯一标识符）、值（JSON 文档）和时间戳。

5. **向量搜索能力**：

   * 系统支持语义搜索，允许通过配置的嵌入函数进行相似性检索，进一步提升存储记忆的召回能力。

### **记忆写入策略**

LangGraph 支持两种主要的记忆写入方式：

1. **实时路径（Hot Path）**：在运行时创建记忆，作为代理应用逻辑的一部分。这可以实现实时更新，但可能会影响延迟。
2. **后台路径（Background Path）**：将记忆创建作为单独的后台任务处理，消除主应用的延迟，但需要仔细的时序管理。


---

# **CAMEL Memory 系统详细实现报告**

## 一、**核心概念详解**

### **1.1 MemoryRecord - 基础存储单元**

`MemoryRecord` 是 CAMEL Memory 系统中所有信息存储的基本数据单元。它是会话信息和知识存储的载体，每条 `MemoryRecord` 代表了一个独立的消息或数据点。

**核心字段说明**：

* `message`: 存储的消息内容（类型：`BaseMessage`）
* `role_at_backend`: 表示在后端的角色，如 `USER`、`ASSISTANT`、`SYSTEM` 等
* `uuid`: 唯一标识符，用于去重和索引
* `timestamp`: 纳秒级精度的时间戳
* `agent_id`: 与该消息关联的智能体ID
* `extra_info`: 附加的键值对元数据

### **1.2 ContextRecord - 检索结果封装**

`ContextRecord` 封装了从 `AgentMemory` 检索的结果，包含相关性评分（`score`）以及检索时间戳。

**核心字段说明**：

* `memory_record`: 原始的 `MemoryRecord`
* `score`: 相关性评分（0.0-1.0）
* `timestamp`: 检索时间戳

## 二、**具体案例：用户消息的完整处理流程**

### **2.1 消息创建和记录**

用户向 ChatAgent 发送消息："What is CAMEL AI?"。首先，消息被转换为一个 `MemoryRecord`。

### **2.2 ChatHistoryMemory的存储实现**

当使用 `ChatHistoryMemory` 时，消息通过以下流程存储：

* **写入过程**：系统将用户的消息存入内存或数据库，生成对应的 `MemoryRecord`。
* **检索过程**：系统在需要时，从内存中检索并返回相关的历史消息，帮助系统生成更加智能的响应。



### **2.4 VectorDBMemory的语义存储**

对于 `VectorDBMemory`，消息处理流程更复杂。此存储机制使用向量数据库进行语义存储，系统通过自动话题更新机制，基于最新的消息自动提取当前的对话话题，用于后续的向量检索。

### **2.5 LongtermAgentMemory的混合策略**

`LongtermAgentMemory` 结合了两种存储方式，结合 **时序性** 和 **语义性** 检索策略：

* `chat_history[:1]`：保留第一条系统消息
* `vector_db_retrieve`：从向量数据库中检索与当前话题相关的历史内容
* `chat_history[1:]`：添加最近的对话历史内容

这种混合策略确保了对话的连贯性，并且能够在跨会话的情况下，使用历史数据和语义信息来生成更为精准的响应。

## 三、**上下文创建和Token管理**

### **3.1 ScoreBasedContextCreator的智能管理**

`ScoreBasedContextCreator` 是 CAMEL 系统用于管理和创建对话上下文的核心组件。它会根据消息的相关性评分、时间戳等因素，智能地决定哪些历史消息应该被纳入当前的上下文。
假设用户在与智能助手进行对话，问到：“上次我询问的天气预报怎么样？”这时，ScoreBasedContextCreator 会根据以下步骤来选择相关的历史消息：

检索历史消息：系统会从内存中找到最近与天气相关的对话记录，比如用户之前询问过天气预报。

计算相关性评分：系统会对这些历史消息进行评分，基于语义相似性计算，将与当前询问“天气”最相关的消息提取出来。

过滤与排序：根据相关性评分和时间戳，系统可能会选择最新的天气相关对话，并根据上下文窗口限制，只保留几条最相关的消息。

构建上下文：最终，这些选中的历史消息（如之前的天气预报查询）会被注入到当前对话的上下文中，以帮助模型更准确地生成回答。

在测试中，系统根据评分（例如 0.9）选择了相关性最高的消息。由于 token 限制，系统只选择了最重要的几条消息。

### **3.2 与ChatAgent的集成流程**

当用户发送消息时，ChatAgent 完整的处理流程如下：

1. **消息接收**：ChatAgent 接收到用户消息。
2. **上下文检索**：调用 `memory.get_context()` 获取相关的历史消息。
3. **消息处理**：结合历史上下文生成响应。
4. **记录更新**：将新的对话记录写入内存（即 `MemoryRecord`）。

## 四、**实际代码示例**

### **4.1 完整的使用示例**

```python
# 示例代码：将消息存储到 ChatHistoryMemory 中
from camel.memory import ChatHistoryMemory, MemoryRecord
chat_memory = ChatHistoryMemory()

# 用户消息
user_message = "What is CAMEL AI?"

# 创建并存储 MemoryRecord
memory_record = MemoryRecord(message=user_message, role_at_backend="USER", timestamp=1234567890)
chat_memory.add_record(memory_record)

# 获取上下文
context = chat_memory.get_context()
```

### **4.2 与ChatAgent的集成示例**

```python
# 示例代码：ChatAgent 处理用户消息
from camel.chat_agent import ChatAgent
chat_agent = ChatAgent(memory=chat_memory)

# 处理用户消息
response = chat_agent.respond("What is CAMEL AI?")
print(response)
```

## 五、**创新点和技术特色**

### **5.1 智能窗口管理创新**

`ChatHistoryBlock` 实现了智能的窗口管理策略，确保 **系统消息永远不被截断**，同时支持灵活的历史消息检索。这对于需要处理大量历史数据的对话系统非常重要。

### **5.2 混合检索策略创新**

`LongtermAgentMemory` 的混合检索策略实现了对 **时序性** 和 **语义性** 的有效平衡。通过结合历史对话和语义信息，系统能够生成更为连贯、相关的对话内容。

### **5.3 评分机制创新**

系统通过 `keep_rate` 参数实现历史消息的 **智能评分衰减**。这一机制确保 **最近的消息** 获得更高的优先级，同时不会忽略长期历史信息。

## 六、**持久化和存储**

### **6.1 多存储后端支持**

系统支持多种存储后端，包括：

* **开发环境**：InMemoryKeyValueStorage
* **生产环境**：JsonStorage、RedisStorage

### **6.2 序列化机制**

`MemoryRecord` 提供完整的 **序列化支持**，确保系统能够跨会话、跨机器进行数据的持久化存储。


---

## AutoGen Memory 技术报告

### 1. 系统架构与核心组成

#### 1.1 协议驱动接口定义

AutoGen Memory 采用协议驱动（Protocol-based）架构，通过标准的 `Memory` 接口来抽象内存操作，核心 API 包括：

* **add**：添加新内存记录。
* **query**：根据查询条件检索相关内存。
* **update\_context**：将检索到的内存自动注入代理上下文。
* **clear**：清空内存内容。
* **close**：释放资源（如关闭连接）\[3]\[18]

所有具体的内存实现方案都必须遵循这一接口规范，确保系统具有良好的可扩展性和后端切换能力。

#### 1.2 内存内容数据结构

所有内存条目封装为 `MemoryContent` 对象，包含以下内容：

* **content**：实际存储的内容（如文本、图片、结构化数据等）。
* **mime\_type**：内容类型（如 `text/markdown`、`image/png` 等，支持多模态）。
* **metadata**：可选的元数据（如时间戳、来源、标签等，用于过滤和管理）\[18]

此数据结构确保内存具有足够的灵活性，支持多种数据类型的存储与检索。

### 2. 主要内存类型实现

| 名称                       | 存储模型            | 检索方式/技术               | 特点                           |
| ------------------------ | --------------- | --------------------- | ---------------------------- |
| **ListMemory**           | 有序列表            | 顺序遍历                  | 轻量级、无依赖，适合用于调试或原型开发          |
| **ChromaDBVectorMemory** | 向量数据库（ChromaDB） | 语义相似性、top-k、分数阈值、向量召回 | 支持大规模语义检索，嵌入模型可插拔            |
| **RedisMemory**          | Redis+RedisVL   | 向量近邻检索、距离阈值、分布式       | 并发性能强，适合多代理（multi-agent）生产环境 |
| **Mem0Memory**           | 第三方平台（Mem0.ai）  | 语义检索、短期/长期/事件多层内存     | 企业级功能，支持云端和本地存储，管理能力强        |

* 每种 Memory 类型都支持上下文注入与异步操作，底层调用通过统一接口实现。\[5]\[3]\[18]

### 3. 内存检索与上下文融合原理

#### 3.1 自动化上下文注入

AutoGen 系统的核心创新之一是自动上下文注入。在每次推理之前，AutoGen 代理会自动对内存执行查询操作，基于最新消息作为检索上下文，并通过 `update_context` 方法将检索到的结果自动注入到代理的上下文中。这一机制消除了手动管理历史记录的需求，提高了推理的相关性和效率。\[3]\[18]

#### 3.2 检索策略

不同的内存类型使用不同的检索策略：

* **ListMemory**：遍历列表并追加上下文。
* **ChromaDB/RedisMemory**：计算查询内容的嵌入向量，执行向量相似性搜索，并根据相似度阈值或前 `k` 结果进行筛选。
* **Mem0Memory**：支持自然语言语义检索，返回按相关性排序的条目。

#### 3.3 多模态支持

AutoGen 支持多种数据类型，包括纯文本、结构化数据（如 JSON）、图片和二进制内容。通过 `mime_type` 和 `metadata` 字段，系统能够灵活约束检索条件和上下文注入的内容。\[18]

### 4. 底层实现机制

#### 4.1 模块化设计

每种内存类型都是独立的模块，具备高度可插拔性，便于替换和扩展。\[5]

#### 4.2 异步事件驱动

内存读写与推理过程并行处理，能够显著提高系统吞吐量和响应速度。尤其适用于多智能体协作的场景，提升了系统的并发能力。\[5]

#### 4.3 持久化与资源管理

如 ChromaDB、Redis 等持久化存储支持断点续执行，资源管理通过 `close` 接口集中管理，确保系统的资源得以合理利用和释放。

#### 4.4 Embedding 可配置

AutoGen 支持多种嵌入模型（如内置的 Transformer 模型 `all-MiniLM-L6-v2`、OpenAI API 和自定义的嵌入脚本），使得检索效果可以根据具体业务需求灵活调整。\[3]\[5]

### 5. 技术优势

AutoGen Memory 的技术优势体现在以下几个方面：

1. **协议标准**：通过统一的协议接口，确保系统能够支持不同的存储后端并具备良好的可扩展性。
2. **自动上下文注入**：系统通过 `update_context` 自动处理上下文更新，避免了手动管理历史记忆的复杂性。
3. **模块解耦**：内存类型的设计为可插拔模块，便于替换和扩展，满足不同业务场景的需求。
4. **并发优化**：异步事件驱动的设计提高了系统吞吐量和响应速度，特别适合多智能体协作环境。
5. **多模态支持**：支持多种数据类型（文本、结构化数据、图片、二进制等），通过灵活的元数据管理，满足不同业务需求的检索要求。


### 7. 典型用例简要流程图

1. **Agent 接收到输入任务消息**。
2. **自动调用 Memory.query** 获取相关历史信息。
3. **使用 Memory.update\_context** 将查询结果动态拼接到系统上下文中。
4. **调用大语言模型进行推理与输出**。
5. **新的消息存入 Memory**，过程闭环。



----

# Memory 系统技术报告 —— LangGraph、CAMEL 与 AutoGen 的实现比较

## 2. 框架概述

### 2.1 LangGraph Memory 系统

LangGraph 的 Memory 系统采用了灵活的多层次存储架构，划分为 **短期内存** 和 **长期内存**，分别处理会话的即时上下文与跨会话的知识。

* **短期内存**（Thread-scoped）:

  * 主要用于存储当前会话的对话历史、会话特定的状态数据、上传的文件以及生成的工件。
  * 持久化机制通过线程范围内的检查点（checkpoints）实现。

* **长期内存**:

  * 存储跨会话的用户数据和知识，支持多种记忆类型：

    * **语义记忆**：存储事实、概念及用户偏好。
    * **情景记忆**：存储与行动相关的过去经验。
    * **程序性记忆**：存储系统指令和规则，用于任务执行。
  * 存储后端为 PostgreSQL，通过 **pgvector** 扩展支持向量检索。

### 2.2 CAMEL Memory 系统

CAMEL Memory 系统的设计重心是自动化的上下文注入和混合存储策略，特别适用于高复杂度和跨会话的对话管理。

* **存储单元**：由 `MemoryRecord` 和 `ContextRecord` 组成，分别用于存储消息内容和检索到的历史记录。

  * **MemoryRecord** 包含消息内容、角色、时间戳等信息。
  * **ContextRecord** 封装了从内存中检索到的内容，包括相关性评分和时间戳。

* **内存类型**：

  * **ChatHistoryMemory**：存储对话历史，支持内存和数据库存储。
  * **VectorDBMemory**：使用向量数据库存储和检索语义信息。
  * **LongtermAgentMemory**：结合时序性与语义性策略，支持混合存储。

* **核心创新**：

  * **自动上下文注入**：每次推理前，自动将检索到的记忆注入到代理上下文中，提高推理准确性。
  * **智能记忆衰减**：根据时间戳和相关性智能调整记忆的优先级，确保最相关的信息优先使用。

### 2.3 AutoGen Memory 系统

AutoGen Memory 系统通过统一的协议驱动接口，使得内存操作可以无缝与不同的存储后端交互，且具备强大的多模态支持和高效的上下文管理。

* **核心组件**：

  * **MemoryContent**：用于封装各种数据类型，包括文本、图像、结构化数据等。
  * 支持 **ListMemory**、**ChromaDBVectorMemory**、**RedisMemory** 和 **Mem0Memory** 等四种存储实现，灵活应对不同需求。

* **自动上下文注入**：通过 `update_context` 方法，自动将最新的记忆注入到模型上下文中，避免手动管理历史记忆。

* **检索策略**：支持基于相似度、语义和距离等多种检索策略，适应多种业务场景的需求。

* **多模态支持**：支持多种数据类型的存储和检索，包括文本、图片、二进制数据等，且通过灵活的元数据管理，确保对不同业务需求的适配。

## 3. 主要差异对比

| **功能维度**    | **LangGraph**            | **CAMEL**                                            | **AutoGen**                                            |
| ----------- | ------------------------ | ---------------------------------------------------- | ------------------------------------------------------ |
| **内存类型**    | 短期内存、长期内存                | ChatHistoryMemory、VectorDBMemory、LongtermAgentMemory | ListMemory、ChromaDBVectorMemory、RedisMemory、Mem0Memory |
| **存储后端**    | PostgreSQL、MongoDB、Redis | 内存存储、PostgreSQL、VectorDB                             | List、ChromaDB、Redis、Mem0                               |
| **上下文注入**   | 自动注入当前会话的上下文             | 自动更新上下文                                              | 自动注入最新的相关记忆到推理上下文中                                     |
| **支持的记忆类型** | 语义记忆、情景记忆、程序性记忆          | 基于消息的存储和检索、长短期记忆的结合                                  | 灵活的多模态存储（文本、图像、结构化数据等）                                 |
| **多模态支持**   | 是                        | 否                                                    | 是                                                      |
| **存储结构**    | 自定义命名空间，JSON 文档形式        | MemoryRecord、ContextRecord                           | MemoryContent、ListMemory、VectorMemory                  |
| **检索策略**    | 基于相似度、top-k、分数阈值、向量召回    | 基于时间和语义的混合检索                                         | 基于相似度、语义、距离等多种检索策略                                     |
| **技术创新**    | 语义记忆与程序性记忆结合的多层次存储       | 自动上下文注入、混合检索策略                                       | 自动上下文注入、多模态支持、协议驱动架构                                   |

## 4. 系统创新性分析

### 4.1 LangGraph 的多层次存储架构

LangGraph 在 Memory 系统设计中采用了 **短期内存** 和 **长期内存** 的分离设计，使得会话信息和跨会话知识得到有效管理。长期内存支持三种基于人类记忆研究的记忆类型，能够为智能代理提供丰富的语义记忆和跨会话知识，适合复杂的知识管理需求。

### 4.2 CAMEL 的自动上下文注入与混合存储策略

CAMEL 的核心创新在于 **自动上下文注入**，通过自动化管理对话历史和检索信息，减少了手动操作，提升了推理准确性。此外，CAMEL 结合了 **时序性** 和 **语义性** 的混合存储策略，使得系统能够在多次对话中维持高度的连贯性和上下文一致性。

### 4.3 AutoGen 的多模态支持与协议驱动架构

AutoGen 通过 **协议驱动** 架构使得系统具备更高的灵活性。统一的 `Memory` 接口允许不同的存储后端无缝切换，减少了开发的复杂性。同时，AutoGen 强大的 **多模态支持** 使得系统可以处理文本、图像等多种数据类型，提供了更广泛的应用场景。

## 5. 总结与建议

三种 Memory 系统各有其优势，适用于不同的业务场景和技术需求：

* **LangGraph** 的多层次存储架构适用于需要跨会话知识管理和长期学习的场景，特别是在语义记忆和情景记忆方面表现突出。
* **CAMEL** 强调自动上下文注入和混合存储策略，适用于复杂对话系统，能够有效管理历史记忆和优化推理过程。
* **AutoGen** 提供了灵活的存储后端支持和强大的多模态处理能力，适合需要多数据类型支持和跨后端切换的应用。

根据不同的技术需求，开发团队可以选择适合的 Memory 系统：

* 如果需要处理多智能体协作和跨会话知识共享，**LangGraph** 是一个理想选择。
* 如果侧重于对话管理和上下文的智能注入，**CAMEL** 会提供更强的支持。
* 对于需要处理多模态数据和高扩展性的应用，**AutoGen** 则是一个非常合适的选择。

